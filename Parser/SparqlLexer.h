/** \file
 *  This C header file was generated by $ANTLR version 3.4
 *
 *     -  From the grammar source file : Sparql.g
 *     -                            On : 2012-10-05 15:14:39
 *     -                 for the lexer : SparqlLexerLexer
 *
 * Editing it, at least manually, is not wise.
 *
 * C language generator and runtime by Jim Idle, jimi|hereisanat|idle|dotgoeshere|ws.
 *
 *
 * The lexer 
SparqlLexer

has the callable functions (rules) shown below,
 * which will invoke the code for the associated rule in the source grammar
 * assuming that the input stream is pointing to a token/text stream that could begin
 * this rule.
 *
 * For instance if you call the first (topmost) rule in a parser grammar, you will
 * get the results of a full parse, but calling a rule half way through the grammar will
 * allow you to pass part of a full token stream to the parser, such as for syntax checking
 * in editors and so on.
 *
 * The parser entry points are called indirectly (by function pointer to function) via
 * a parser context typedef pSparqlLexer, which is returned from a call to SparqlLexerNew().
 *
 * As this is a generated lexer, it is unlikely you will call it 'manually'. However
 * the methods are provided anyway.
 *
 * The methods in pSparqlLexer are  as follows:
 *
 *  - 
 void
      pSparqlLexer->WS(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->BASE(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->PREFIX(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->SELECT(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->DISTINCT(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->REDUCED(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->CONSTRUCT(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->DESCRIBE(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->ASK(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->FROM(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->NAMED(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->WHERE(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->ORDER(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->BY(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->ASC(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->DESC(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->LIMIT(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->OFFSET(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->OPTIONAL(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->GRAPH(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->UNION(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->FILTER(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->A(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->STR(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->LANG(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->LANGMATCHES(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->DATATYPE(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->BOUND(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->SAMETERM(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->ISIRI(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->ISURI(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->ISBLANK(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->ISLITERAL(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->REGEX(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->SUBSTR(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->TRUE(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->FALSE(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->LOAD(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->CLEAR(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->DROP(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->ADD(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->MOVE(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->COPY(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->CREATE(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->DELETE(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->INSERT(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->USING(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->SILENT(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->DEFAULT(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->ALL(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->DATA(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->WITH(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->INTO(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->TO(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->AS(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->GROUP(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->HAVING(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->UNDEF(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->BINDINGS(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->SERVICE(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->BIND(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->MINUS_KEYWORD(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->IRI(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->URI(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->BNODE(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->RAND(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->ABS(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->CEIL(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->FLOOR(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->ROUND(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->CONCAT(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->STRLEN(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->UCASE(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->LCASE(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->ENCODE_FOR_URI(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->CONTAINS(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->STRSTARTS(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->STRENDS(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->YEAR(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->MONTH(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->DAY(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->HOURS(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->MINUTES(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->SECONDS(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->TIMEZONE(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->TZ(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->NOW(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->MD5(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->SHA1(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->SHA224(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->SHA256(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->SHA384(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->SHA512(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->COALESCE(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->IF(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->STRLANG(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->STRDT(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->ISNUMERIC(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->COUNT(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->SUM(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->MIN(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->MAX(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->AVG(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->SAMPLE(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->GROUP_CONCAT(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->NOT(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->IN(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->EXISTS(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->SEPARATOR(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->PNAME_NS(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->PNAME_LN(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->BLANK_NODE_LABEL(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->VAR1(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->VAR2(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->LANGTAG(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->INTEGER(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->DECIMAL(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->DOUBLE(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->INTEGER_POSITIVE(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->DECIMAL_POSITIVE(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->DOUBLE_POSITIVE(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->INTEGER_NEGATIVE(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->DECIMAL_NEGATIVE(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->DOUBLE_NEGATIVE(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->EXPONENT(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->STRING_LITERAL1(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->STRING_LITERAL2(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->STRING_LITERAL_LONG1(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->STRING_LITERAL_LONG2(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->ECHAR(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->IRI_REF(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->IRI_REF_CHARACTERS(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->PN_CHARS_U(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->VARNAME(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->PN_CHARS(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->PN_PREFIX(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->PN_LOCAL(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->PN_CHARS_BASE(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->DIGIT(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->COMMENT(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->EOL(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->REFERENCE(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->LESS_EQUAL(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->GREATER_EQUAL(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->NOT_EQUAL(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->AND(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->OR(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->INVERSE(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->OPEN_BRACE(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->CLOSE_BRACE(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->OPEN_CURLY_BRACE(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->CLOSE_CURLY_BRACE(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->OPEN_SQUARE_BRACKET(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->CLOSE_SQUARE_BRACKET(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->SEMICOLON(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->DOT(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->PLUS(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->MINUS(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->SIGN(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->ASTERISK(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->QUESTION_MARK(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->COMMA(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->NEGATION(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->DIVIDE(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->EQUAL(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->LESS(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->GREATER(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->PIPE(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->ANY(pSparqlLexer)
 *  - 
 void
      pSparqlLexer->Tokens(pSparqlLexer)
 * 
 *
 * The return type for any particular rule is of course determined by the source
 * grammar file.
 */
// [The "BSD license"]
// Copyright (c) 2005-2009 Jim Idle, Temporal Wave LLC
// http://www.temporal-wave.com
// http://www.linkedin.com/in/jimidle
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

#ifndef	_SparqlLexer_H
#define _SparqlLexer_H
/* =============================================================================
 * Standard antlr3 C runtime definitions
 */
#include    <antlr3.h>

/* End of standard antlr 3 runtime definitions
 * =============================================================================
 */

#ifdef __cplusplus
extern "C" {
#endif

// Forward declare the context typedef so that we can use it before it is
// properly defined. Delegators and delegates (from import statements) are
// interdependent and their context structures contain pointers to each other
// C only allows such things to be declared if you pre-declare the typedef.
//
typedef struct SparqlLexer_Ctx_struct SparqlLexer, * pSparqlLexer;



#ifdef	ANTLR3_WINDOWS
// Disable: Unreferenced parameter,							- Rules with parameters that are not used
//          constant conditional,							- ANTLR realizes that a prediction is always true (synpred usually)
//          initialized but unused variable					- tree rewrite variables declared but not needed
//          Unreferenced local variable						- lexer rule declares but does not always use _type
//          potentially unitialized variable used			- retval always returned from a rule
//			unreferenced local function has been removed	- susually getTokenNames or freeScope, they can go without warnigns
//
// These are only really displayed at warning level /W4 but that is the code ideal I am aiming at
// and the codegen must generate some of these warnings by necessity, apart from 4100, which is
// usually generated when a parser rule is given a parameter that it does not use. Mostly though
// this is a matter of orthogonality hence I disable that one.
//
#pragma warning( disable : 4100 )
#pragma warning( disable : 4101 )
#pragma warning( disable : 4127 )
#pragma warning( disable : 4189 )
#pragma warning( disable : 4505 )
#pragma warning( disable : 4701 )
#endif

/* ========================
 * BACKTRACKING IS ENABLED
 * ========================
 */


/** Context tracking structure for 
SparqlLexer

 */
struct SparqlLexer_Ctx_struct
{
    /** Built in ANTLR3 context tracker contains all the generic elements
     *  required for context tracking.
     */
    pANTLR3_LEXER    pLexer;

     void
     (*mWS)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mBASE)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mPREFIX)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mSELECT)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mDISTINCT)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mREDUCED)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mCONSTRUCT)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mDESCRIBE)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mASK)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mFROM)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mNAMED)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mWHERE)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mORDER)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mBY)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mASC)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mDESC)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mLIMIT)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mOFFSET)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mOPTIONAL)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mGRAPH)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mUNION)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mFILTER)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mA)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mSTR)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mLANG)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mLANGMATCHES)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mDATATYPE)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mBOUND)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mSAMETERM)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mISIRI)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mISURI)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mISBLANK)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mISLITERAL)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mREGEX)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mSUBSTR)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mTRUE)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mFALSE)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mLOAD)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mCLEAR)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mDROP)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mADD)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mMOVE)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mCOPY)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mCREATE)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mDELETE)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mINSERT)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mUSING)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mSILENT)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mDEFAULT)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mALL)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mDATA)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mWITH)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mINTO)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mTO)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mAS)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mGROUP)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mHAVING)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mUNDEF)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mBINDINGS)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mSERVICE)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mBIND)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mMINUS_KEYWORD)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mIRI)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mURI)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mBNODE)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mRAND)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mABS)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mCEIL)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mFLOOR)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mROUND)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mCONCAT)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mSTRLEN)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mUCASE)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mLCASE)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mENCODE_FOR_URI)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mCONTAINS)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mSTRSTARTS)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mSTRENDS)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mYEAR)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mMONTH)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mDAY)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mHOURS)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mMINUTES)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mSECONDS)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mTIMEZONE)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mTZ)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mNOW)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mMD5)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mSHA1)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mSHA224)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mSHA256)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mSHA384)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mSHA512)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mCOALESCE)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mIF)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mSTRLANG)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mSTRDT)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mISNUMERIC)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mCOUNT)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mSUM)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mMIN)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mMAX)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mAVG)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mSAMPLE)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mGROUP_CONCAT)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mNOT)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mIN)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mEXISTS)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mSEPARATOR)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mPNAME_NS)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mPNAME_LN)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mBLANK_NODE_LABEL)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mVAR1)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mVAR2)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mLANGTAG)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mINTEGER)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mDECIMAL)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mDOUBLE)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mINTEGER_POSITIVE)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mDECIMAL_POSITIVE)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mDOUBLE_POSITIVE)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mINTEGER_NEGATIVE)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mDECIMAL_NEGATIVE)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mDOUBLE_NEGATIVE)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mEXPONENT)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mSTRING_LITERAL1)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mSTRING_LITERAL2)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mSTRING_LITERAL_LONG1)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mSTRING_LITERAL_LONG2)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mECHAR)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mIRI_REF)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mIRI_REF_CHARACTERS)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mPN_CHARS_U)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mVARNAME)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mPN_CHARS)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mPN_PREFIX)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mPN_LOCAL)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mPN_CHARS_BASE)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mDIGIT)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mCOMMENT)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mEOL)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mREFERENCE)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mLESS_EQUAL)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mGREATER_EQUAL)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mNOT_EQUAL)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mAND)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mOR)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mINVERSE)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mOPEN_BRACE)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mCLOSE_BRACE)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mOPEN_CURLY_BRACE)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mCLOSE_CURLY_BRACE)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mOPEN_SQUARE_BRACKET)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mCLOSE_SQUARE_BRACKET)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mSEMICOLON)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mDOT)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mPLUS)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mMINUS)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mSIGN)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mASTERISK)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mQUESTION_MARK)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mCOMMA)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mNEGATION)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mDIVIDE)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mEQUAL)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mLESS)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mGREATER)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mPIPE)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mANY)	(struct SparqlLexer_Ctx_struct * ctx);

     void
     (*mTokens)	(struct SparqlLexer_Ctx_struct * ctx);

    const char * (*getGrammarFileName)();
    void            (*reset)  (struct SparqlLexer_Ctx_struct * ctx);
    void	    (*free)   (struct SparqlLexer_Ctx_struct * ctx);
};

// Function protoypes for the constructor functions that external translation units
// such as delegators and delegates may wish to call.
//
ANTLR3_API pSparqlLexer SparqlLexerNew         (
pANTLR3_INPUT_STREAM
 instream);
ANTLR3_API pSparqlLexer SparqlLexerNewSSD      (
pANTLR3_INPUT_STREAM
 instream, pANTLR3_RECOGNIZER_SHARED_STATE state);

/** Symbolic definitions of all the tokens that the 
lexer
 will work with.
 * \{
 *
 * Antlr will define EOF, but we can't use that as it it is too common in
 * in C header files and that would be confusing. There is no way to filter this out at the moment
 * so we just undef it here for now. That isn't the value we get back from C recognizers
 * anyway. We are looking for ANTLR3_TOKEN_EOF.
 */
#ifdef	EOF
#undef	EOF
#endif
#ifdef	Tokens
#undef	Tokens
#endif
#define EOF      -1
#define A      4
#define ABS      5
#define ADD      6
#define ALL      7
#define AND      8
#define ANY      9
#define ARG_LIST      10
#define AS      11
#define ASC      12
#define ASK      13
#define ASTERISK      14
#define AVG      15
#define BASE      16
#define BIND      17
#define BINDINGS      18
#define BINDING_VALUE      19
#define BLANK_NODE      20
#define BLANK_NODE_LABEL      21
#define BNODE      22
#define BOUND      23
#define BY      24
#define CEIL      25
#define CLEAR      26
#define CLOSE_BRACE      27
#define CLOSE_CURLY_BRACE      28
#define CLOSE_SQUARE_BRACKET      29
#define COALESCE      30
#define COLLECTION      31
#define COMMA      32
#define COMMENT      33
#define CONCAT      34
#define CONSTRUCT      35
#define CONSTRUCT_TRIPLES      36
#define CONTAINS      37
#define COPY      38
#define COUNT      39
#define CREATE      40
#define DATA      41
#define DATATYPE      42
#define DAY      43
#define DECIMAL      44
#define DECIMAL_NEGATIVE      45
#define DECIMAL_POSITIVE      46
#define DEFAULT      47
#define DELETE      48
#define DESC      49
#define DESCRIBE      50
#define DIGIT      51
#define DISTINCT      52
#define DIVIDE      53
#define DOT      54
#define DOUBLE      55
#define DOUBLE_NEGATIVE      56
#define DOUBLE_POSITIVE      57
#define DROP      58
#define ECHAR      59
#define ENCODE_FOR_URI      60
#define EOL      61
#define EQUAL      62
#define EXISTS      63
#define EXPONENT      64
#define EXPRESSION_LIST      65
#define FALSE      66
#define FILTER      67
#define FLOOR      68
#define FROM      69
#define FUNCTION      70
#define GRAPH      71
#define GREATER      72
#define GREATER_EQUAL      73
#define GROUP      74
#define GROUP_BY      75
#define GROUP_CONCAT      76
#define GROUP_GRAPH_PATTERN      77
#define HAVING      78
#define HOURS      79
#define IF      80
#define IN      81
#define INSERT      82
#define INTEGER      83
#define INTEGER_NEGATIVE      84
#define INTEGER_POSITIVE      85
#define INTO      86
#define INVERSE      87
#define IRI      88
#define IRI_REF      89
#define IRI_REF_CHARACTERS      90
#define ISBLANK      91
#define ISIRI      92
#define ISLITERAL      93
#define ISNUMERIC      94
#define ISURI      95
#define LANG      96
#define LANGMATCHES      97
#define LANGTAG      98
#define LCASE      99
#define LESS      100
#define LESS_EQUAL      101
#define LIMIT      102
#define LOAD      103
#define MAX      104
#define MD5      105
#define MIN      106
#define MINUS      107
#define MINUS_KEYWORD      108
#define MINUTES      109
#define MODIFY      110
#define MONTH      111
#define MOVE      112
#define NAMED      113
#define NEGATION      114
#define NOT      115
#define NOT_EQUAL      116
#define NOT_EXISTS      117
#define NOW      118
#define OBJECT      119
#define OFFSET      120
#define OPEN_BRACE      121
#define OPEN_CURLY_BRACE      122
#define OPEN_SQUARE_BRACKET      123
#define OPTIONAL      124
#define OR      125
#define ORDER      126
#define ORDER_BY      127
#define ORDER_CONDITION      128
#define PATH      129
#define PATH_NEGATED      130
#define PATH_PRIMARY      131
#define PATH_SEQUENCE      132
#define PIPE      133
#define PLUS      134
#define PNAME_LN      135
#define PNAME_NS      136
#define PN_CHARS      137
#define PN_CHARS_BASE      138
#define PN_CHARS_U      139
#define PN_LOCAL      140
#define PN_PREFIX      141
#define PREDICATE      142
#define PREFIX      143
#define PROLOGUE      144
#define QUERY      145
#define QUESTION_MARK      146
#define RAND      147
#define REDUCED      148
#define REFERENCE      149
#define REGEX      150
#define ROUND      151
#define SAMETERM      152
#define SAMPLE      153
#define SECONDS      154
#define SELECT      155
#define SELECT_CLAUSE      156
#define SEMICOLON      157
#define SEPARATOR      158
#define SERVICE      159
#define SHA1      160
#define SHA224      161
#define SHA256      162
#define SHA384      163
#define SHA512      164
#define SIGN      165
#define SILENT      166
#define STR      167
#define STRDT      168
#define STRENDS      169
#define STRING_LITERAL1      170
#define STRING_LITERAL2      171
#define STRING_LITERAL_LONG1      172
#define STRING_LITERAL_LONG2      173
#define STRLANG      174
#define STRLEN      175
#define STRSTARTS      176
#define SUBJECT      177
#define SUBSELECT      178
#define SUBSTR      179
#define SUM      180
#define TIMEZONE      181
#define TO      182
#define TRIPLES_BLOCK      183
#define TRIPLES_NODE      184
#define TRIPLES_SAME_SUBJECT      185
#define TRIPLES_TEMPLATE      186
#define TRUE      187
#define TZ      188
#define UCASE      189
#define UNARY      190
#define UNARY_MINUS      191
#define UNARY_NOT      192
#define UNARY_PLUS      193
#define UNDEF      194
#define UNION      195
#define UPDATE      196
#define URI      197
#define USING      198
#define VAR      199
#define VAR1      200
#define VAR2      201
#define VARNAME      202
#define WHERE      203
#define WHERE_CLAUSE      204
#define WITH      205
#define WORKLOAD      206
#define WS      207
#define YEAR      208
#ifdef	EOF
#undef	EOF
#define	EOF	ANTLR3_TOKEN_EOF
#endif

#ifndef TOKENSOURCE
#define TOKENSOURCE(lxr) lxr->pLexer->rec->state->tokSource
#endif

/* End of token definitions for SparqlLexer
 * =============================================================================
 */
/** } */

#ifdef __cplusplus
}
#endif

#endif

/* END - Note:Keep extra line feed to satisfy UNIX systems */
